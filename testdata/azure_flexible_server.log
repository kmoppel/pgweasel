2025-05-21 11:00:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/8023A90, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:00:05 UTC-682db221.4e8-LOG:  disconnection: session time: 0:00:20.053 user=azuresu database=azure_sys host=127.0.0.1 port=37940
2025-05-21 11:00:09 UTC-682db225.4eb-LOG:  disconnection: session time: 0:00:20.039 user=azuresu database=azure_maintenance host=127.0.0.1 port=54794
2025-05-21 11:00:10 UTC-682db226.4ec-LOG:  disconnection: session time: 0:00:20.031 user=azuresu database=postgres host=127.0.0.1 port=54806
2025-05-21 11:00:10 UTC-682db23a.501-LOG:  connection received: host=127.0.0.1 port=34834
2025-05-21 11:00:10 UTC-682db23a.501-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:10 UTC-682db23a.501-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:13 UTC-682db23d.504-LOG:  connection received: host=127.0.0.1 port=34850
2025-05-21 11:00:13 UTC-682db23d.504-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:13 UTC-682db23d.504-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:16 UTC-682db240.505-LOG:  connection received: host=127.0.0.1 port=34852
2025-05-21 11:00:16 UTC-682db240.505-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:16 UTC-682db240.505-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:16 UTC-682db240.505-LOG:  duration: 5.031 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:00:30 UTC-682db23a.501-LOG:  disconnection: session time: 0:00:20.046 user=azuresu database=postgres host=127.0.0.1 port=34834
2025-05-21 11:00:30 UTC-682db24e.50a-LOG:  connection received: host=127.0.0.1 port=46378
2025-05-21 11:00:30 UTC-682db24e.50a-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:30 UTC-682db24e.50a-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:33 UTC-682db23d.504-LOG:  disconnection: session time: 0:00:20.034 user=azuresu database=azure_maintenance host=127.0.0.1 port=34850
2025-05-21 11:00:36 UTC-682db254.50d-LOG:  connection received: host=127.0.0.1 port=46390
2025-05-21 11:00:36 UTC-682db240.505-LOG:  disconnection: session time: 0:00:20.037 user=azuresu database=azure_sys host=127.0.0.1 port=34852
2025-05-21 11:00:36 UTC-682db254.50d-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:36 UTC-682db254.50d-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:44 UTC-682db254.50d-LOG:  duration: 5.596 ms  execute _p4: commit
2025-05-21 11:00:47 UTC-682db25f.512-LOG:  connection received: host=127.0.0.1 port=46266
2025-05-21 11:00:47 UTC-682db25f.512-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:47 UTC-682db25f.512-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:50 UTC-682db24e.50a-LOG:  disconnection: session time: 0:00:20.045 user=azuresu database=postgres host=127.0.0.1 port=46378
2025-05-21 11:00:50 UTC-682db262.513-LOG:  connection received: host=127.0.0.1 port=46892
2025-05-21 11:00:50 UTC-682db262.513-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:50 UTC-682db262.513-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:56 UTC-682db254.50d-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_maintenance host=127.0.0.1 port=46390
2025-05-21 11:00:57 UTC-682db269.51f-LOG:  connection received: host=127.0.0.1 port=46906
2025-05-21 11:00:57 UTC-682db269.51f-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:00:57 UTC-682db269.51f-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:00:57 UTC-682db269.51f-LOG:  disconnection: session time: 0:00:00.034 user=azuresu database=postgres host=127.0.0.1 port=46906
2025-05-21 11:00:59 UTC-682db013.355-LOG:  checkpoint starting: time
2025-05-21 11:01:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/90006B0, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:01:00 UTC-682db26c.535-LOG:  connection received: host=127.0.0.1 port=55304
2025-05-21 11:01:00 UTC-682db26c.535-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:00 UTC-682db26c.535-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:07 UTC-682db013.355-LOG:  checkpoint complete: wrote 80 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=7.801 s, sync=0.012 s, total=7.846 s; sync files=51, longest=0.008 s, average=0.001 s; distance=144 kB, estimate=144 kB; lsn=0/9000A10, redo lsn=0/8024310
2025-05-21 11:01:07 UTC-682db25f.512-LOG:  disconnection: session time: 0:00:20.042 user=azuresu database=azure_sys host=127.0.0.1 port=46266
2025-05-21 11:01:10 UTC-682db262.513-LOG:  disconnection: session time: 0:00:20.035 user=azuresu database=postgres host=127.0.0.1 port=46892
2025-05-21 11:01:10 UTC-682db276.540-LOG:  connection received: host=127.0.0.1 port=58414
2025-05-21 11:01:10 UTC-682db276.540-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:10 UTC-682db276.540-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:18 UTC-682db27e.544-LOG:  connection received: host=127.0.0.1 port=45792
2025-05-21 11:01:18 UTC-682db27e.544-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:18 UTC-682db27e.544-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:18 UTC-682db27e.544-LOG:  duration: 5.450 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:01:20 UTC-682db26c.535-LOG:  disconnection: session time: 0:00:20.034 user=azuresu database=azure_maintenance host=127.0.0.1 port=55304
2025-05-21 11:01:24 UTC-682db284.547-LOG:  connection received: host=127.0.0.1 port=45804
2025-05-21 11:01:24 UTC-682db284.547-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:24 UTC-682db284.547-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:30 UTC-682db276.540-LOG:  disconnection: session time: 0:00:20.039 user=azuresu database=postgres host=127.0.0.1 port=58414
2025-05-21 11:01:30 UTC-682db28a.549-LOG:  connection received: host=127.0.0.1 port=34234
2025-05-21 11:01:30 UTC-682db28a.549-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:30 UTC-682db28a.549-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:38 UTC-682db27e.544-LOG:  disconnection: session time: 0:00:20.033 user=azuresu database=azure_sys host=127.0.0.1 port=45792
2025-05-21 11:01:44 UTC-682db284.547-LOG:  disconnection: session time: 0:00:20.038 user=azuresu database=azure_maintenance host=127.0.0.1 port=45804
2025-05-21 11:01:48 UTC-682db29c.550-LOG:  connection received: host=127.0.0.1 port=37980
2025-05-21 11:01:48 UTC-682db29c.550-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:48 UTC-682db29c.550-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:49 UTC-682db29d.551-LOG:  connection received: host=127.0.0.1 port=37992
2025-05-21 11:01:49 UTC-682db29d.551-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:49 UTC-682db29d.551-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:49 UTC-682db29d.551-LOG:  duration: 5.269 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:01:49 UTC-682db29d.551-LOG:  duration: 5.827 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:01:50 UTC-682db28a.549-LOG:  disconnection: session time: 0:00:20.056 user=azuresu database=postgres host=127.0.0.1 port=34234
2025-05-21 11:01:51 UTC-682db29f.552-LOG:  connection received: host=127.0.0.1 port=38002
2025-05-21 11:01:51 UTC-682db29f.552-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:51 UTC-682db29f.552-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:58 UTC-682db2a6.55d-LOG:  connection received: host=127.0.0.1 port=38014
2025-05-21 11:01:58 UTC-682db2a6.55d-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:01:58 UTC-682db2a6.55d-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:01:58 UTC-682db2a6.55d-LOG:  disconnection: session time: 0:00:00.039 user=azuresu database=postgres host=127.0.0.1 port=38014
2025-05-21 11:02:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/9001370, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:02:08 UTC-682db29c.550-LOG:  disconnection: session time: 0:00:20.052 user=azuresu database=azure_maintenance host=127.0.0.1 port=37980
2025-05-21 11:02:09 UTC-682db29d.551-LOG:  disconnection: session time: 0:00:20.036 user=azuresu database=azure_sys host=127.0.0.1 port=37992
2025-05-21 11:02:11 UTC-682db29f.552-LOG:  disconnection: session time: 0:00:20.036 user=azuresu database=postgres host=127.0.0.1 port=38002
2025-05-21 11:02:11 UTC-682db2b3.561-LOG:  connection received: host=127.0.0.1 port=45580
2025-05-21 11:02:11 UTC-682db2b3.561-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:11 UTC-682db2b3.561-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:12 UTC-682db2b4.564-LOG:  connection received: host=127.0.0.1 port=45590
2025-05-21 11:02:12 UTC-682db2b4.564-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:12 UTC-682db2b4.564-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:20 UTC-682db2bc.566-LOG:  connection received: host=127.0.0.1 port=49886
2025-05-21 11:02:20 UTC-682db2bc.566-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:20 UTC-682db2bc.566-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:20 UTC-682db2bc.566-LOG:  duration: 5.864 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:02:20 UTC-682db2bc.566-LOG:  duration: 5.724 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:02:31 UTC-682db2b3.561-LOG:  disconnection: session time: 0:00:20.788 user=azuresu database=postgres host=127.0.0.1 port=45580
2025-05-21 11:02:32 UTC-682db2b4.564-LOG:  disconnection: session time: 0:00:20.029 user=azuresu database=azure_maintenance host=127.0.0.1 port=45590
2025-05-21 11:02:36 UTC-682db2cc.56c-LOG:  connection received: host=127.0.0.1 port=37154
2025-05-21 11:02:36 UTC-682db2cc.56c-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:36 UTC-682db2cc.56c-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:39 UTC-682db2cf.56e-LOG:  connection received: host=127.0.0.1 port=57328
2025-05-21 11:02:39 UTC-682db2cf.56e-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:39 UTC-682db2cf.56e-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:40 UTC-682db2bc.566-LOG:  disconnection: session time: 0:00:20.043 user=azuresu database=azure_sys host=127.0.0.1 port=49886
2025-05-21 11:02:51 UTC-682db2db.572-LOG:  connection received: host=127.0.0.1 port=36212
2025-05-21 11:02:51 UTC-682db2db.572-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:51 UTC-682db2db.572-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:51 UTC-682db2db.572-LOG:  duration: 6.089 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:02:56 UTC-682db2cc.56c-LOG:  disconnection: session time: 0:00:20.032 user=azuresu database=azure_maintenance host=127.0.0.1 port=37154
2025-05-21 11:02:58 UTC-682db2e2.57e-LOG:  connection received: host=127.0.0.1 port=36220
2025-05-21 11:02:58 UTC-682db2e2.57e-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:02:58 UTC-682db2e2.57e-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:02:58 UTC-682db2e2.57e-LOG:  disconnection: session time: 0:00:00.040 user=azuresu database=postgres host=127.0.0.1 port=36220
2025-05-21 11:02:59 UTC-682db2cf.56e-LOG:  disconnection: session time: 0:00:20.085 user=azuresu database=postgres host=127.0.0.1 port=57328
2025-05-21 11:03:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/9001C58, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:03:00 UTC-682db2e4.580-LOG:  connection received: host=127.0.0.1 port=46132
2025-05-21 11:03:00 UTC-682db2e4.580-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:00 UTC-682db2e4.580-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:00 UTC-682db2e4.581-LOG:  connection received: host=127.0.0.1 port=46134
2025-05-21 11:03:00 UTC-682db2e4.581-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:00 UTC-682db2e4.581-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:11 UTC-682db2db.572-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_sys host=127.0.0.1 port=36212
2025-05-21 11:03:20 UTC-682db2e4.580-LOG:  disconnection: session time: 0:00:20.036 user=azuresu database=postgres host=127.0.0.1 port=46132
2025-05-21 11:03:20 UTC-682db2e4.581-LOG:  disconnection: session time: 0:00:20.043 user=azuresu database=azure_maintenance host=127.0.0.1 port=46134
2025-05-21 11:03:21 UTC-682db2f9.587-LOG:  connection received: host=127.0.0.1 port=57110
2025-05-21 11:03:21 UTC-682db2f9.587-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:21 UTC-682db2f9.587-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:22 UTC-682db2fa.589-LOG:  connection received: host=127.0.0.1 port=57122
2025-05-21 11:03:22 UTC-682db2fa.589-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:22 UTC-682db2fa.589-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:22 UTC-682db2fa.589-LOG:  duration: 7.285 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:03:22 UTC-682db2fa.589-LOG:  duration: 6.251 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:03:24 UTC-682db2fc.58b-LOG:  connection received: host=127.0.0.1 port=57128
2025-05-21 11:03:24 UTC-682db2fc.58b-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:24 UTC-682db2fc.58b-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:41 UTC-682db2f9.587-LOG:  disconnection: session time: 0:00:20.038 user=azuresu database=postgres host=127.0.0.1 port=57110
2025-05-21 11:03:41 UTC-682db30d.590-LOG:  connection received: host=127.0.0.1 port=56258
2025-05-21 11:03:41 UTC-682db30d.590-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:41 UTC-682db30d.590-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:42 UTC-682db2fa.589-LOG:  disconnection: session time: 0:00:20.038 user=azuresu database=azure_sys host=127.0.0.1 port=57122
2025-05-21 11:03:44 UTC-682db2fc.58b-LOG:  disconnection: session time: 0:00:20.050 user=azuresu database=azure_maintenance host=127.0.0.1 port=57128
2025-05-21 11:03:46 UTC-682db312.592-LOG:  connection received: host=127.0.0.1 port=56270
2025-05-21 11:03:46 UTC-682db312.592-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:46 UTC-682db312.592-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:48 UTC-682db314.595-LOG:  connection received: host=127.0.0.1 port=58742
2025-05-21 11:03:48 UTC-682db314.595-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:48 UTC-682db314.595-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:53 UTC-682db319.597-LOG:  connection received: host=127.0.0.1 port=58744
2025-05-21 11:03:53 UTC-682db319.597-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:53 UTC-682db319.597-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:58 UTC-682db31e.5a1-LOG:  connection received: host=127.0.0.1 port=47886
2025-05-21 11:03:58 UTC-682db31e.5a1-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:03:58 UTC-682db31e.5a1-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:03:58 UTC-682db31e.5a1-LOG:  disconnection: session time: 0:00:00.038 user=azuresu database=postgres host=127.0.0.1 port=47886
2025-05-21 11:04:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/9002638, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:04:01 UTC-682db30d.590-LOG:  disconnection: session time: 0:00:20.033 user=azuresu database=postgres host=127.0.0.1 port=56258
2025-05-21 11:04:01 UTC-682db321.5a3-LOG:  connection received: host=127.0.0.1 port=47896
2025-05-21 11:04:01 UTC-682db321.5a4-LOG:  connection received: host=127.0.0.1 port=47898
2025-05-21 11:04:01 UTC-682db321.5a3-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:01 UTC-682db321.5a3-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:01 UTC-682db321.5a4-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:01 UTC-682db321.5a4-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:04 UTC-682db314.595-LOG:  duration: 9.611 ms  execute _p4: commit
2025-05-21 11:04:06 UTC-682db312.592-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_sys host=127.0.0.1 port=56270
2025-05-21 11:04:08 UTC-682db328.5a7-LOG:  connection received: host=91.129.106.131 port=44657
2025-05-21 11:04:08 UTC-682db328.5a7-LOG:  connection authenticated: identity=\"peakasutaja\" method=md5 (/datadrive/pg/data/pg_hba.conf:29)
2025-05-21 11:04:08 UTC-682db328.5a7-LOG:  connection authorized: user=peakasutaja database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:08 UTC-682db328.5a7-ERROR:  syntax error at or near \"asdasd\" at character 1","statement": "asdasd
2025-05-21 11:04:08 UTC-682db328.5a7-LOG:  disconnection: session time: 0:00:00.479 user=peakasutaja database=postgres host=91.129.106.131 port=44657
2025-05-21 11:04:08 UTC-682db314.595-LOG:  disconnection: session time: 0:00:20.038 user=azuresu database=azure_maintenance host=127.0.0.1 port=58742
2025-05-21 11:04:12 UTC-682db32c.5aa-LOG:  connection received: host=127.0.0.1 port=58168
2025-05-21 11:04:12 UTC-682db32c.5aa-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:12 UTC-682db32c.5aa-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:13 UTC-682db319.597-LOG:  disconnection: session time: 0:00:20.092 user=azuresu database=azure_sys host=127.0.0.1 port=58744
2025-05-21 11:04:20 UTC-682db321.5a3-LOG:  duration: 5.600 ms  execute <unnamed>: WITH max_con AS (SELECT setting::numeric FROM pg_catalog.pg_settings WHERE name = 'max_connections') SELECT COALESCE(SUM(numbackends), 0) as active_connections, ROUND(SUM(numbackends)/MAX(setting), 4) AS pct_connections, MAX(setting) AS max_connections FROM pg_catalog.pg_stat_database, max_con
2025-05-21 11:04:21 UTC-682db321.5a3-LOG:  disconnection: session time: 0:00:20.134 user=azuresu database=postgres host=127.0.0.1 port=47896
2025-05-21 11:04:24 UTC-682db338.5ae-LOG:  connection received: host=127.0.0.1 port=60566
2025-05-21 11:04:24 UTC-682db338.5ae-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:24 UTC-682db338.5ae-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:32 UTC-682db32c.5aa-LOG:  disconnection: session time: 0:00:20.036 user=azuresu database=azure_maintenance host=127.0.0.1 port=58168
2025-05-21 11:04:36 UTC-682db344.5b2-LOG:  connection received: host=127.0.0.1 port=45602
2025-05-21 11:04:37 UTC-682db344.5b2-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:37 UTC-682db344.5b2-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:41 UTC-682db321.5a4-LOG:  disconnection: session time: 0:00:40.085 user=azuresu database=postgres host=127.0.0.1 port=47898
2025-05-21 11:04:42 UTC-682db34a.5b4-LOG:  connection received: host=127.0.0.1 port=42276
2025-05-21 11:04:42 UTC-682db34a.5b4-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:42 UTC-682db34a.5b4-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:44 UTC-682db338.5ae-LOG:  disconnection: session time: 0:00:20.046 user=azuresu database=azure_sys host=127.0.0.1 port=60566
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  connection received: host=91.129.106.131 port=44668
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  connection authenticated: identity=\"peakasutaja\" method=md5 (/datadrive/pg/data/pg_hba.conf:29)
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  connection authorized: user=peakasutaja database=postgres application_name=pgbench SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  duration: 5.545 ms  statement: select o.n, p.partstrat, pg_catalog.count(i.inhparent) from pg_catalog.pg_class as c join pg_catalog.pg_namespace as n on (n.oid = c.relnamespace) cross join lateral (select pg_catalog.array_position(pg_catalog.current_schemas(true), n.nspname)) as o(n) left join pg_catalog.pg_partitioned_table as p on (p.partrelid = c.oid) left join pg_catalog.pg_inherits as i on (c.oid = i.inhparent) where c.relname = 'pgbench_accounts' and o.n is not null group by 1, 2 order by 1 asc limit 1
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  duration: 9.828 ms  statement: truncate pgbench_history
2025-05-21 11:04:53 UTC-682db355.5b9-LOG:  disconnection: session time: 0:00:00.748 user=peakasutaja database=postgres host=91.129.106.131 port=44668
2025-05-21 11:04:53 UTC-682db355.5ba-LOG:  connection received: host=91.129.106.131 port=44633
2025-05-21 11:04:54 UTC-682db355.5ba-LOG:  connection authenticated: identity=\"peakasutaja\" method=md5 (/datadrive/pg/data/pg_hba.conf:29)
2025-05-21 11:04:54 UTC-682db355.5ba-LOG:  connection authorized: user=peakasutaja database=postgres application_name=pgbench SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:55 UTC-682db357.5bc-LOG:  connection received: host=127.0.0.1 port=38668
2025-05-21 11:04:55 UTC-682db357.5bc-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:55 UTC-682db357.5bc-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:55 UTC-682db357.5bc-LOG:  duration: 5.045 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:04:55 UTC-682db357.5bc-LOG:  duration: 5.267 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:04:57 UTC-682db344.5b2-LOG:  disconnection: session time: 0:00:20.422 user=azuresu database=azure_maintenance host=127.0.0.1 port=45602
2025-05-21 11:04:58 UTC-682db35a.5c6-LOG:  connection received: host=127.0.0.1 port=40526
2025-05-21 11:04:58 UTC-682db35a.5c6-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:04:58 UTC-682db35a.5c6-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:04:58 UTC-682db35a.5c6-LOG:  disconnection: session time: 0:00:00.046 user=azuresu database=postgres host=127.0.0.1 port=40526
2025-05-21 11:05:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/9005E18, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:05:00 UTC-682db35c.5c8-LOG:  connection received: host=127.0.0.1 port=40534
2025-05-21 11:05:00 UTC-682db35c.5c8-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:00 UTC-682db35c.5c8-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:01 UTC-682db35c.5c8-LOG:  duration: 42.994 ms  execute _p4: commit
2025-05-21 11:05:02 UTC-682db34a.5b4-LOG:  disconnection: session time: 0:00:20.037 user=azuresu database=postgres host=127.0.0.1 port=42276
2025-05-21 11:05:02 UTC-682db35e.5c9-LOG:  connection received: host=127.0.0.1 port=40550
2025-05-21 11:05:02 UTC-682db35e.5c9-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:02 UTC-682db35e.5c9-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:15 UTC-682db357.5bc-LOG:  disconnection: session time: 0:00:20.047 user=azuresu database=azure_sys host=127.0.0.1 port=38668
2025-05-21 11:05:20 UTC-682db35c.5c8-LOG:  disconnection: session time: 0:00:20.048 user=azuresu database=azure_maintenance host=127.0.0.1 port=40534
2025-05-21 11:05:22 UTC-682db35e.5c9-LOG:  disconnection: session time: 0:00:20.072 user=azuresu database=postgres host=127.0.0.1 port=40550
2025-05-21 11:05:22 UTC-682db372.5d0-LOG:  connection received: host=127.0.0.1 port=42382
2025-05-21 11:05:22 UTC-682db372.5d0-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:22 UTC-682db372.5d0-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:22 UTC-682db372.5d1-LOG:  connection received: host=127.0.0.1 port=42396
2025-05-21 11:05:23 UTC-682db372.5d1-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:23 UTC-682db372.5d1-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:23 UTC-682db372.5d1-LOG:  duration: 21.490 ms  execute _p4: commit
2025-05-21 11:05:24 UTC-682db355.5ba-LOG:  duration: 29699.862 ms  execute P_0: SELECT abalance FROM pgbench_accounts WHERE aid = $1;","detail": "parameters: $1 = '8061732'
2025-05-21 11:05:24 UTC-682db355.5ba-LOG:  disconnection: session time: 0:00:30.249 user=peakasutaja database=postgres host=91.129.106.131 port=44633
2025-05-21 11:05:26 UTC-682db376.5d3-LOG:  connection received: host=127.0.0.1 port=42412
2025-05-21 11:05:26 UTC-682db376.5d3-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:26 UTC-682db376.5d3-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:26 UTC-682db376.5d3-LOG:  duration: 6.907 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:05:27 UTC-682db376.5d3-LOG:  duration: 9.832 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:05:42 UTC-682db372.5d0-LOG:  disconnection: session time: 0:00:20.094 user=azuresu database=postgres host=127.0.0.1 port=42382
2025-05-21 11:05:42 UTC-682db386.5d9-LOG:  connection received: host=127.0.0.1 port=42550
2025-05-21 11:05:42 UTC-682db386.5d9-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:42 UTC-682db386.5d9-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:43 UTC-682db372.5d1-LOG:  disconnection: session time: 0:00:20.226 user=azuresu database=azure_maintenance host=127.0.0.1 port=42396
2025-05-21 11:05:46 UTC-682db38a.5da-LOG:  connection received: host=127.0.0.1 port=42558
2025-05-21 11:05:46 UTC-682db376.5d3-LOG:  disconnection: session time: 0:00:20.037 user=azuresu database=azure_sys host=127.0.0.1 port=42412
2025-05-21 11:05:46 UTC-682db38a.5da-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:47 UTC-682db38a.5da-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:57 UTC-682db395.5df-LOG:  connection received: host=127.0.0.1 port=53180
2025-05-21 11:05:57 UTC-682db395.5df-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:57 UTC-682db395.5df-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:58 UTC-682db395.5df-LOG:  duration: 5.613 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:05:58 UTC-682db395.5df-LOG:  duration: 7.555 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:05:58 UTC-682db396.5e8-LOG:  connection received: host=127.0.0.1 port=43256
2025-05-21 11:05:58 UTC-682db396.5e8-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:05:58 UTC-682db396.5e8-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:05:58 UTC-682db396.5e8-LOG:  disconnection: session time: 0:00:00.053 user=azuresu database=postgres host=127.0.0.1 port=43256
2025-05-21 11:05:59 UTC-682db013.35e-LOG:  pg_qs: qs bgworker: worker woke up and performed operations, with query data store as off
2025-05-21 11:05:59 UTC-682db013.35e-LOG:  pg_qs: qs bgworker: current instance is a primary
2025-05-21 11:05:59 UTC-682db013.35e-LOG:  pg_qs: qs bgworker: default_transaction_read_only is set to false
2025-05-21 11:05:59 UTC-682db013.35e-LOG:  pgms_wait_sampling: entry_reset called","context": "SQL statement \"SELECT query_store.staging_ws_data_reset()\"
2025-05-21 11:05:59 UTC-682db013.35e-LOG:  pg_qs: qs bgworker: worker finished successfully in 5.748806 ms, with query store as off, is_writtable_instance as unknown and having_schema as unknown
2025-05-21 11:06:00 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/A0000A8, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:06:02 UTC-682db386.5d9-LOG:  disconnection: session time: 0:00:20.047 user=azuresu database=postgres host=127.0.0.1 port=42550
2025-05-21 11:06:02 UTC-682db39a.601-LOG:  connection received: host=127.0.0.1 port=43272
2025-05-21 11:06:02 UTC-682db39a.601-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:02 UTC-682db39a.601-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:07 UTC-682db38a.5da-LOG:  disconnection: session time: 0:00:20.045 user=azuresu database=azure_maintenance host=127.0.0.1 port=42558
2025-05-21 11:06:10 UTC-682db3a2.607-LOG:  connection received: host=127.0.0.1 port=46178
2025-05-21 11:06:11 UTC-682db3a2.607-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:11 UTC-682db3a2.607-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:18 UTC-682db395.5df-LOG:  disconnection: session time: 0:00:20.041 user=azuresu database=azure_sys host=127.0.0.1 port=53180
2025-05-21 11:06:22 UTC-682db39a.601-LOG:  disconnection: session time: 0:00:20.054 user=azuresu database=postgres host=127.0.0.1 port=43272
2025-05-21 11:06:22 UTC-682db3ae.60c-LOG:  connection received: host=127.0.0.1 port=42216
2025-05-21 11:06:22 UTC-682db3ae.60c-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:22 UTC-682db3ae.60c-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:28 UTC-682db3b4.60f-LOG:  connection received: host=127.0.0.1 port=38028
2025-05-21 11:06:29 UTC-682db3b4.60f-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:29 UTC-682db3b4.60f-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:29 UTC-682db3b4.60f-LOG:  duration: 13.874 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:06:29 UTC-682db3b4.60f-LOG:  duration: 13.692 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:06:31 UTC-682db3a2.607-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_maintenance host=127.0.0.1 port=46178
2025-05-21 11:06:34 UTC-682db3ba.611-LOG:  connection received: host=127.0.0.1 port=38038
2025-05-21 11:06:35 UTC-682db3ba.611-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:35 UTC-682db3ba.611-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:42 UTC-682db3ae.60c-LOG:  disconnection: session time: 0:00:20.043 user=azuresu database=postgres host=127.0.0.1 port=42216
2025-05-21 11:06:42 UTC-682db3c2.615-LOG:  connection received: host=127.0.0.1 port=56686
2025-05-21 11:06:42 UTC-682db3c2.615-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:42 UTC-682db3c2.615-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:49 UTC-682db3b4.60f-LOG:  disconnection: session time: 0:00:20.073 user=azuresu database=azure_sys host=127.0.0.1 port=38028
2025-05-21 11:06:50 UTC-682db3ba.611-LOG:  duration: 6.262 ms  execute _p4: commit
2025-05-21 11:06:55 UTC-682db3ba.611-LOG:  disconnection: session time: 0:00:20.052 user=azuresu database=azure_maintenance host=127.0.0.1 port=38038
2025-05-21 11:06:58 UTC-682db3d2.622-LOG:  connection received: host=127.0.0.1 port=35312
2025-05-21 11:06:58 UTC-682db3d2.622-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:58 UTC-682db3d2.622-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:58 UTC-682db3d2.622-LOG:  disconnection: session time: 0:00:00.034 user=azuresu database=postgres host=127.0.0.1 port=35312
2025-05-21 11:06:58 UTC-682db3d2.623-LOG:  connection received: host=127.0.0.1 port=35326
2025-05-21 11:06:59 UTC-682db3d2.623-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:06:59 UTC-682db3d2.623-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:06:59 UTC-682db3d3.625-LOG:  connection received: host=127.0.0.1 port=35340
2025-05-21 11:07:00 UTC-682db3d3.625-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:00 UTC-682db3d3.625-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:01 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/A000A48, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:07:02 UTC-682db3c2.615-LOG:  disconnection: session time: 0:00:20.027 user=azuresu database=postgres host=127.0.0.1 port=56686
2025-05-21 11:07:02 UTC-682db3d6.627-LOG:  connection received: host=127.0.0.1 port=35348
2025-05-21 11:07:03 UTC-682db3d6.627-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:03 UTC-682db3d6.627-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:19 UTC-682db3d2.623-LOG:  disconnection: session time: 0:00:20.032 user=azuresu database=azure_maintenance host=127.0.0.1 port=35326
2025-05-21 11:07:20 UTC-682db3d3.625-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_sys host=127.0.0.1 port=35340
2025-05-21 11:07:22 UTC-682db3ea.62d-LOG:  connection received: host=127.0.0.1 port=35880
2025-05-21 11:07:23 UTC-682db3d6.627-LOG:  disconnection: session time: 0:00:20.038 user=azuresu database=postgres host=127.0.0.1 port=35348
2025-05-21 11:07:23 UTC-682db3ea.62d-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:23 UTC-682db3ea.62d-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:23 UTC-682db3eb.62e-LOG:  connection received: host=127.0.0.1 port=35884
2025-05-21 11:07:23 UTC-682db3eb.62e-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:23 UTC-682db3eb.62e-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:29 UTC-682db3eb.62e-LOG:  duration: 27.322 ms  statement: DISCARD ALL
2025-05-21 11:07:29 UTC-682db3eb.62e-LOG:  duration: 16.233 ms  parse <unnamed>: SELECT COALESCE(SUM(numbackends), 0) as active_connections FROM pg_catalog.pg_stat_database
2025-05-21 11:07:29 UTC-682db3eb.62e-LOG:  duration: 9.201 ms  bind <unnamed>: SELECT MAX(CASE WHEN slot.slot_type='physical' AND (slot.slot_name LIKE 'azure_asyncreplica%' or slot.slot_name LIKE 'azure_geoasyncreplica%') THEN CASE WHEN stat.replay_lsn IS NULL THEN pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn() , slot.restart_lsn)::BIGINT ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn() , stat.replay_lsn)::BIGINT END ELSE NULL END ) AS physical_replication_delay_in_bytes, MAX(CASE WHEN slot.slot_type='logical' THEN CASE WHEN stat.replay_lsn IS NULL THEN pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn() , slot.restart_lsn)::BIGINT ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn() , stat.replay_lsn)::BIGINT END ELSE NULL END) AS logical_replication_delay_in_bytes FROM pg_catalog.pg_replication_slots AS slot LEFT JOIN pg_catalog.pg_stat_replication AS stat ON stat.pid = slot.active_pid
2025-05-21 11:07:30 UTC-682db3f3.631-LOG:  connection received: host=127.0.0.1 port=38534
2025-05-21 11:07:31 UTC-682db3f3.631-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:31 UTC-682db3f3.631-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:31 UTC-682db3f3.631-LOG:  duration: 5.386 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:07:43 UTC-682db3ea.62d-LOG:  disconnection: session time: 0:00:20.072 user=azuresu database=azure_maintenance host=127.0.0.1 port=35880
2025-05-21 11:07:43 UTC-682db3eb.62e-LOG:  disconnection: session time: 0:00:20.041 user=azuresu database=postgres host=127.0.0.1 port=35884
2025-05-21 11:07:43 UTC-682db3ff.636-LOG:  connection received: host=127.0.0.1 port=43142
2025-05-21 11:07:43 UTC-682db3ff.636-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:43 UTC-682db3ff.636-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:47 UTC-682db403.637-LOG:  connection received: host=127.0.0.1 port=43150
2025-05-21 11:07:47 UTC-682db403.637-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:47 UTC-682db403.637-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:51 UTC-682db3f3.631-LOG:  disconnection: session time: 0:00:20.056 user=azuresu database=azure_sys host=127.0.0.1 port=38534
2025-05-21 11:07:59 UTC-682db40f.645-LOG:  connection received: host=127.0.0.1 port=49300
2025-05-21 11:07:59 UTC-682db40f.645-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:07:59 UTC-682db40f.645-LOG:  connection authorized: user=azuresu database=postgres application_name=psql SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:07:59 UTC-682db40f.645-LOG:  disconnection: session time: 0:00:00.036 user=azuresu database=postgres host=127.0.0.1 port=49300
2025-05-21 11:08:01 UTC-682db013.35b-LOG:  [pg-availability]: current_lsn: 0/A001330, current_lsn_counter: 6, spi_return_msg: SPI_OK_UPDATE
2025-05-21 11:08:02 UTC-682db412.647-LOG:  connection received: host=127.0.0.1 port=49312
2025-05-21 11:08:02 UTC-682db412.647-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:02 UTC-682db412.647-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:02 UTC-682db412.647-LOG:  duration: 9.603 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:08:02 UTC-682db412.647-LOG:  duration: 8.254 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:08:03 UTC-682db3ff.636-LOG:  disconnection: session time: 0:00:20.037 user=azuresu database=postgres host=127.0.0.1 port=43142
2025-05-21 11:08:04 UTC-682db414.649-LOG:  connection received: host=127.0.0.1 port=49326
2025-05-21 11:08:04 UTC-682db414.649-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:04 UTC-682db414.649-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:07 UTC-682db403.637-LOG:  disconnection: session time: 0:00:20.040 user=azuresu database=azure_maintenance host=127.0.0.1 port=43150
2025-05-21 11:08:11 UTC-682db41b.64b-LOG:  connection received: host=127.0.0.1 port=47374
2025-05-21 11:08:11 UTC-682db41b.64b-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:11 UTC-682db41b.64b-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:22 UTC-682db412.647-LOG:  disconnection: session time: 0:00:20.048 user=azuresu database=azure_sys host=127.0.0.1 port=49312
2025-05-21 11:08:24 UTC-682db414.649-LOG:  disconnection: session time: 0:00:20.055 user=azuresu database=postgres host=127.0.0.1 port=49326
2025-05-21 11:08:25 UTC-682db429.651-LOG:  connection received: host=127.0.0.1 port=38854
2025-05-21 11:08:25 UTC-682db429.651-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:25 UTC-682db429.651-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:31 UTC-682db41b.64b-LOG:  disconnection: session time: 0:00:20.032 user=azuresu database=azure_maintenance host=127.0.0.1 port=47374
2025-05-21 11:08:33 UTC-682db431.654-LOG:  connection received: host=127.0.0.1 port=41240
2025-05-21 11:08:33 UTC-682db431.654-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:33 UTC-682db431.654-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:33 UTC-682db431.654-LOG:  duration: 10.162 ms  parse <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:08:33 UTC-682db431.654-LOG:  duration: 9.238 ms  bind <unnamed>: With slots_info AS (\r\n  SELECT \r\n    slot.slot_name,\r\n    slot.active,\r\n    slot.slot_type,\r\n    stat.write_lsn,\r\n    stat.flush_lsn,\r\n    stat.sync_state,\r\n    slot.restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END as wal_retention_from_restart_lsn,\r\n    stat.replay_lsn,\r\n    CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END as replay_lsn_else_restart_lsn,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(CASE WHEN stat.replay_lsn IS NULL THEN slot.restart_lsn ELSE stat.replay_lsn END) END as must_retain_wal_file,\r\n    CASE WHEN pg_is_in_recovery() THEN NULL \r\n      ELSE (CASE WHEN stat.replay_lsn IS NULL THEN NULL ELSE pg_catalog.pg_wal_lsn_diff(pg_catalog.pg_current_wal_lsn(), slot.restart_lsn)::BIGINT END) \r\n    END as wal_retention_from_replay_lsn\r\n  FROM pg_catalog.pg_replication_slots slot \r\n  LEFT JOIN pg_catalog.pg_stat_replication stat ON slot.active_pid = stat.pid\r\n),\r\nstandby_and_walreplica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name LIKE 'azure_standby%' or slot_name like 'wal_replica%' ),\r\nread_replica_slot_info as (SELECT * FROM slots_info where slot_type = 'physical' and slot_name not LIKE 'azure_standby%' and slot_name not like 'wal_replica%' )\r\nSELECT\r\n  (\r\n   SELECT row_to_json(t1) logical_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM slots_info where slot_type = 'logical' and active = true),\r\n     (SELECT count(*) as inactive FROM slots_info where slot_type = 'logical' and active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM slots_info where slot_type = 'logical'  order by replay_lsn_else_restart_lsn ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) read_replica_slots FROM \r\n   ( SELECT \r\n       (SELECT count(*) as active FROM read_replica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM read_replica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM read_replica_slot_info order by replay_lsn_else_restart_lsn limit 4 ) as t ) as lagging_order ) as t1),\r\n  (\r\n   SELECT row_to_json(t1) standby_and_walreplica_slots FROM \r\n   ( SELECT \r\n     (SELECT count(*) as active FROM standby_and_walreplica_slot_info where active = true),\r\n     (SELECT count(*) as inactive FROM standby_and_walreplica_slot_info where active <> true),\r\n     (SELECT jsonb_agg(row_to_json(t)) \r\n       FROM ( SELECT * FROM standby_and_walreplica_slot_info ) as t ) as lagging_order ) as t1),\r\n  (\r\n   Select row_to_json(t)::text as checkpoint_info \r\n    FROM (\r\n      Select\r\n        (SELECT  trunc(MAX(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - xact_start))) AS max_age FROM pg_stat_activity) oldest_live_tx_age,\r\n        trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - checkpoint_time)) as seconds_after_last_checkpoint ,   \r\n        timeline_id,  \r\n        checkpoint_lsn, \r\n        TO_CHAR(checkpoint_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as checkpoint_time,\r\n        CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(checkpoint_lsn) END AS checkpoint_wal_file,\r\n        redo_lsn,  \r\n        redo_wal_file,  \r\n        buffers_alloc , \r\n        block_size,  \r\n        now()-stats_reset stats_reset \r\n      from pg_catalog.pg_control_checkpoint(), pg_stat_bgwriter,(SELECT cast(current_setting('block_size') AS integer) AS block_size) as sub_query) as t ),\r\n  (\r\n   Select  row_to_json(t)::text as archiver_info\r\n    FROM (\r\n      Select\r\n            trunc(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - last_archived_time)) last_archival, \r\n            (last_failed_wal IS NULL OR last_failed_wal <= last_archived_wal) is_archiving,  \r\n            trunc( CASE \r\n                    WHEN archived_count = 0 OR EXTRACT(EPOCH FROM age(now(), stats_reset)) = 0 THEN 0 \r\n                    ELSE CAST(archived_count AS NUMERIC)*60 / EXTRACT(EPOCH FROM age(now(), stats_reset)) \r\n                    END ) wals_archived_per_minute,  \r\n            last_archived_wal, \r\n            TO_CHAR(last_archived_time at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS') as last_archived_time,\r\n            last_failed_wal, \r\n            archived_count,  \r\n            failed_count, \r\n            now()-stats_reset as stats_reset\r\n          from pg_catalog.pg_stat_archiver ) as t ),\r\n  (\r\n   Select row_to_json(t)::text as wal_upload_related_details \r\n        FROM (\r\n            SELECT\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(pg_catalog.pg_current_wal_lsn()) END as current),\r\n              (SELECT CASE WHEN pg_is_in_recovery() THEN NULL ELSE pg_catalog.pg_walfile_name(flush_lsn) END as quorum_committed FROM slots_info where slot_type = 'physical' and sync_state='quorum' order by flush_lsn desc limit 1 ), \r\n              (SELECT CAST(pg_catalog.current_setting('azure.enforce_ha_quorom') AS BOOLEAN) AS enforce_ha_quorom),\r\n              (SELECT pg_catalog.current_setting('synchronous_standby_names') AS synchronous_standby_names),\r\n              (SELECT CAST(pg_catalog.pg_is_in_recovery() AS BOOLEAN) AS pg_is_in_recovery)\r\n    )  as t ),\r\n  (\r\n   select TO_CHAR(pg_catalog.now() at time zone 'utc', 'YYYY-MM-DD HH24:MI:SS')) as time_fetched
2025-05-21 11:08:35 UTC-682db433.655-LOG:  connection received: host=127.0.0.1 port=41242
2025-05-21 11:08:35 UTC-682db433.655-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:35 UTC-682db433.655-LOG:  connection authorized: user=azuresu database=azure_maintenance SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:45 UTC-682db429.651-LOG:  disconnection: session time: 0:00:20.044 user=azuresu database=postgres host=127.0.0.1 port=38854
2025-05-21 11:08:46 UTC-682db43e.659-LOG:  connection received: host=127.0.0.1 port=48186
2025-05-21 11:08:46 UTC-682db43e.659-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:46 UTC-682db43e.659-LOG:  connection authorized: user=azuresu database=postgres SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
2025-05-21 11:08:47 UTC-682db43f.65a-LOG:  connection received: host=127.0.0.1 port=48190
2025-05-21 11:08:47 UTC-682db43f.65a-LOG:  connection authenticated: identity=\"CN=azuresu.d481e194acdf.database.azure.com\" method=cert (/datadrive/pg/data/pg_hba.conf:12)
2025-05-21 11:08:47 UTC-682db43f.65a-LOG:  connection authorized: user=azuresu database=azure_sys SSL enabled (protocol=TLSv1.3, cipher=TLS_AES_256_GCM_SHA384, bits=256)
